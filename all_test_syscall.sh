#!/bin/bash


syscalls=(
    "abort"
    "accept"
    "accept4"
    "access"
    "acct"
    "add_key"
    "adjtimex"
    "alarm"
    "bind"
    "bpf"
    "brk"
    "cacheflush"
    "capget"
    "capset"
    "chdir"
    "chmod"
    "chown"
    "chroot"
    "clock_adjtime"
    "clock_getres"
    "clock_gettime"
    "clock_nanosleep"
    "clock_settime"
    "clone"
    "clone3"
    "close"
    "close_range"
    "process_vm_readv"
    "process_vm_writev"
    "confstr"
    "connect"
    "copy_file_range"
    "creat"
    "delete_module"
    "dup"
    "dup2"
    "dup3"
    "epoll"
    "epoll_create"
    "epoll_create1"
    "epoll_ctl"
    "epoll_pwait"
    "epoll_wait"
    "eventfd"
    "eventfd2"
    "execl"
    "execle"
    "execlp"
    "execv"
    "execve"
    "execveat"
    "execvp"
    "exit"
    "exit_group"
    "faccessat"
    "faccessat2"
    "fadvise"
    "fallocate"
    "fanotify"
    "fchdir"
    "fchmod"
    "fchmodat"
    "fchown"
    "fchownat"
    "fcntl"
    "fdatasync"
    "fgetxattr"
    "finit_module"
    "flistxattr"
    "flock"
    "fmtmsg"
    "fork"
    "fpathconf"
    "fremovexattr"
    "fsconfig"
    "fsetxattr"
    "fsmount"
    "fsopen"
    "fspick"
    "fstat"
    "fstatat"
    "fstatfs"
    "fsync"
    "ftruncate"
    "futex"
    "futimesat"
    "getcontext"
    "getcpu"
    "getcwd"
    "getdents"
    "getdomainname"
    "getdtablesize"
    "getegid"
    "geteuid"
    "getgid"
    "getgroups"
    "gethostbyname_r"
    "gethostid"
    "gethostname"
    "getitimer"
    "get_mempolicy"
    "getpagesize"
    "getpeername"
    "getpgid"
    "getpgrp"
    "getpid"
    "getppid"
    "getpriority"
    "getrandom"
    "getresgid"
    "getresuid"
    "getrlimit"
    "get_robust_list"
    "getrusage"
    "getsid"
    "getsockname"
    "getsockopt"
    "gettid"
    "gettimeofday"
    "getuid"
    "getxattr"
    "init_module"
    "inotify"
    "inotify_init"
    "io_cancel"
    "ioctl"
    "io_destroy"
    "io_getevents"
    "ioperm"
    "io_pgetevents"
    "iopl"
    "ioprio"
    "io_setup"
    "io_submit"
    "io_uring"
    "msgctl"
    "msgget"
    "msgrcv"
    "msgsnd"
    "msgstress"
    "semctl"
    "semget"
    "semop"
    "shmat"
    "shmctl"
    "shmdt"
    "shmget"
    "kcmp"
    "keyctl"
    "kill"
    "lchown"
    "lgetxattr"
    "link"
    "linkat"
    "listen"
    "listxattr"
    "llistxattr"
    "llseek"
    "lremovexattr"
    "lseek"
    "lstat"
    "madvise"
    "mallinfo"
    "mallinfo2"
    "mallopt"
    "mbind"
    "membarrier"
    "memcmp"
    "memcpy"
    "memfd_create"
    "memset"
    "migrate_pages"
    "mincore"
    "mkdir"
    "mkdirat"
    "mknod"
    "mknodat"
    "mlock"
    "mlock2"
    "mlockall"
    "mmap"
    "modify_ldt"
    "mount"
    "mount_setattr"
    "move_mount"
    "move_pages"
    "mprotect"
    "mq_notify"
    "mq_open"
    "mq_timedreceive"
    "mq_timedsend"
    "mq_unlink"
    "mremap"
    "msync"
    "munlock"
    "munlockall"
    "munmap"
    "name_to_handle_at"
    "nanosleep"
    "newuname"
    "nftw"
    "nice"
    "open"
    "openat"
    "openat2"
    "open_by_handle_at"
    "open_tree"
    "pathconf"
    "pause"
    "perf_event_open"
    "personality"
    "pidfd_getfd"
    "pidfd_open"
    "pidfd_send_signal"
    "pipe"
    "pipe2"
    "pivot_root"
    "pkeys"
    "poll"
    "ppoll"
    "prctl"
    "pread"
    "preadv"
    "preadv2"
    "process_madvise"
    "profil"
    "pselect"
    "ptrace"
    "pwrite"
    "pwritev"
    "pwritev2"
    "quotactl"
    "read"
    "readahead"
    "readdir"
    "readlink"
    "readlinkat"
    "readv"
    "realpath"
    "reboot"
    "recv"
    "recvfrom"
    "recvmmsg"
    "recvmsg"
    "remap_file_pages"
    "removexattr"
    "rename"
    "renameat"
    "renameat2"
    "request_key"
    "rmdir"
    "rt_sigaction"
    "rt_sigprocmask"
    "rt_sigqueueinfo"
    "rt_sigsuspend"
    "rt_sigtimedwait"
    "rt_tgsigqueueinfo"
    "sbrk"
    "sched_getaffinity"
    "sched_getattr"
    "sched_getparam"
    "sched_get_priority_max"
    "sched_get_priority_min"
    "sched_getscheduler"
    "sched_rr_get_interval"
    "sched_setaffinity"
    "sched_setattr"
    "sched_setparam"
    "sched_setscheduler"
    "sched_yield"
    "select"
    "send"
    "sendfile"
    "sendmmsg"
    "sendmsg"
    "sendto"
    "setdomainname"
    "setegid"
    "setfsgid"
    "setfsuid"
    "setgid"
    "setgroups"
    "sethostname"
    "setitimer"
    "set_mempolicy"
    "setns"
    "setpgid"
    "setpgrp"
    "setpriority"
    "setregid"
    "setresgid"
    "setresuid"
    "setreuid"
    "setrlimit"
    "set_robust_list"
    "setsid"
    "setsockopt"
    "set_thread_area"
    "set_tid_address"
    "settimeofday"
    "setuid"
    "setxattr"
    "sgetmask"
    "sigaction"
    "sigaltstack"
    "sighold"
    "signal"
    "signalfd"
    "signalfd4"
    "sigpending"
    "sigprocmask"
    "sigrelse"
    "sigsuspend"
    "sigtimedwait"
    "sigwait"
    "sigwaitinfo"
    "socket"
    "socketcall"
    "socketpair"
    "sockioctl"
    "splice"
    "ssetmask"
    "stat"
    "statfs"
    "statvfs"
    "statx"
    "stime"
    "string"
    "swapoff"
    "swapon"
    "switch"
    "symlink"
    "symlinkat"
    "sync"
    "sync_file_range"
    "syncfs"
    "syscall"
    "sysconf"
    "sysctl"
    "sysfs"
    "sysinfo"
    "syslog"
    "tee"
    "tgkill"
    "time"
    "timer_create"
    "timer_delete"
    "timerfd"
    "timer_getoverrun"
    "timer_gettime"
    "timer_settime"
    "times"
    "tkill"
    "truncate"
    "ulimit"
    "umask"
    "umount"
    "umount2"
    "uname"
    "unlink"
    "unlinkat"
    "unshare"
    "userfaultfd"
    "ustat"
    "utime"
    "utimensat"
    "utimes"
    "vfork"
    "vhangup"
    "vmsplice"
    "wait"
    "wait4"
    "waitid"
    "waitpid"
    "write"
    "writev"
)

mkdir -p syscall_logs

timeout_duration=3600 # 10 seconds, for example

do_task() {
    local id=$1
    local file=$2
    echo "Starting task $id $file"
    sleep $((RANDOM % 5 + 1)) # Simulate task by sleeping for a random duration between 1 and 5 seconds
    echo "Completed task $id $file"
}


# Loop over each syscall
file_index=0
N_REP=8
for syscall in "${syscalls[@]}"; do
    # Select the file based on the current index
    file="/home/siyuan/small_image_reps/image.ext4_rep${file_index}"

    # do_task "$syscall" "$file" &
    # Start the task
    timeout $timeout_duration ./run_ECPT_syscall "$syscall" "$file" &

    # Increment and reset the file index if needed
    file_index=$(( (file_index + 1) % N_REP ))

    # Every four syscalls, wait for the tasks to complete
    if [ $((file_index % N_REP)) -eq 0 ]; then
        wait
    fi
done

wait